/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. MiniJavaAst.jj */
/*@egen*/options {
    JAVA_UNICODE_ESCAPE = true;
    STATIC = false;
                 
                   
                              
                           
    LOOKAHEAD = 3;
    FORCE_LA_CHECK = true;
}

PARSER_BEGIN(MiniJavaParser)
package AST;

import java.io.*;
public class MiniJavaParser/*@bgen(jjtree)*/implements MiniJavaParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTMiniJavaParserState jjtree = new JJTMiniJavaParserState();

/*@egen*/
    public static void main(String[] args){
        MiniJavaParser minij = null;

        if (args.length > 0) {
            System.out.println("Reading " + args[0] + "...");
            try {
                InputStream istream = new FileInputStream(new File(args[0]));
                minij = new MiniJavaParser(istream);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println("Reading from standard input...");
            minij = new MiniJavaParser(System.in);
        }

        try {
            SimpleNode n = minij.Program();
            PrettyPrintVisitor prettyPrintVisitor = new PrettyPrintVisitor();
            n.jjtAccept(prettyPrintVisitor, null);
        } catch (Exception e) {
            System.out.println("Something went downside: " + e.getMessage());
            e.printStackTrace();
    }
}
}
PARSER_END(MiniJavaParser)

TOKEN : {
    < CLASS: "class" >                               |
    < LBRACE: "{" >                                  |
    < RBRACE: "}" >                                  |
    < PUBLIC: "public" >                             |
    < STATIC: "static" >                             |
    < VOID: "void" >                                 |
    < STRING: "String" >                             |
    < INT: "int" >                                   |
    < BOOLEAN: "boolean" >                           |
    < MAIN: "main" >                                 |
    < EXTENDS: "extends" >                           |
    < RETURN: "return" >                             |
    < IF: "if" >                                     |
    < ELSE: "else" >                                 |
    < WHILE: "while" >                               |
    < TRUE: "true" >                                 |
    < FALSE: "false" >                               |
    < LENGTH: "length" >                             |
    < THIS: "this" >                                 |
    < NEW: "new" >                                   |
    < LPAREN: "(" >                                  |
    < RPAREN: ")" >                                  |
    < AND: "&&" >                                    |
    < STAR: "*" >                                    |
    < FSLASH: "/" >                                  |
    < PLUS: "+" >                                    |
    < MINUS: "-" >                                   |
    < PRINT: "System.out.println" >                  |
    < LSQUARE: "[" >                                 |
    < RSQUARE: "]" >                                 |
    < GT: ">" >                                      |
    < LT: "<" >                                      |
    < ASSIGN: "=" >                                  |
    < SEMI: ";" >                                    |
    < COMMA: "," >                                   |
    < DOT: "." >                                     |
    < EXCLAIM: "!" >                                 |
    < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)* >   |
    < INTEGER_LITERAL: (<DIGIT>)+ >                  |
    < #LETTER: ["_", "a"-"z", "A"-"Z"] >             |
    < #DIGIT:  ["0"-"9"] >
}

SKIP : {
    " "     |
    "\t"    |
    "\n"    |
    "\r"    |
    < "//" (~["\r", "\n"])* ("\r" | "\n" | "\r\n") >    |
    < "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" >
}


/* ====== Grammar Rules with Semantic actions ====== */
SimpleNode Program(): {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
    try {
/*@egen*/
    MainClass() (ClassDecl())* <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MainClass(): {/*@bgen(jjtree) MainClass */
  ASTMainClass jjtn000 = new ASTMainClass(JJTMAINCLASS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MainClass */
    try {
/*@egen*/
    <CLASS> Identifier() <LBRACE>
        <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LSQUARE> <RSQUARE> Identifier() <RPAREN> <LBRACE>
            Statement()
        <RBRACE>
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ClassDecl()      : {}
{
    LOOKAHEAD(3) ClassDeclSimple()       |
    LOOKAHEAD(3) ClassDeclExtends()
}

void ClassDeclSimple(): {/*@bgen(jjtree) ClassDeclSimple */
  ASTClassDeclSimple jjtn000 = new ASTClassDeclSimple(JJTCLASSDECLSIMPLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClassDeclSimple */
    try {
/*@egen*/
    <CLASS> Identifier() <LBRACE>
        (VarDecl())* (MethodDecl())*
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ClassDeclExtends(): {/*@bgen(jjtree) ClassDeclExtends */
  ASTClassDeclExtends jjtn000 = new ASTClassDeclExtends(JJTCLASSDECLEXTENDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClassDeclExtends */
    try {
/*@egen*/
    <CLASS> Identifier() <EXTENDS> Identifier() <LBRACE>
        (VarDecl())* (MethodDecl())*
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarDecl(): {/*@bgen(jjtree) VarDecl */
  ASTVarDecl jjtn000 = new ASTVarDecl(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDecl */
    try {
/*@egen*/
    Type() Identifier() <SEMI>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MethodDecl(): {/*@bgen(jjtree) MethodDecl */
  ASTMethodDecl jjtn000 = new ASTMethodDecl(JJTMETHODDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodDecl */
    try {
/*@egen*/
    <PUBLIC> Type() Identifier() <LPAREN> FormalList() <RPAREN> <LBRACE>
        (LOOKAHEAD(2) VarDecl())* (Statement())* <RETURN> Exp() <SEMI>
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FormalList(): {/*@bgen(jjtree) FormalList */
  ASTFormalList jjtn000 = new ASTFormalList(JJTFORMALLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FormalList */
    try {
/*@egen*/
    (Type() Identifier() (FormalRest())*)?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FormalRest(): {/*@bgen(jjtree) FormalRest */
  ASTFormalRest jjtn000 = new ASTFormalRest(JJTFORMALREST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FormalRest */
    try {
/*@egen*/
    <COMMA> Type() Identifier()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Type(): {/*@bgen(jjtree) Type */
  ASTType jjtn000 = new ASTType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    <BOOLEAN>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/       { jjtn000.token = token; }          |
    LOOKAHEAD(2) <INT> <LSQUARE> <RSQUARE>/*@bgen(jjtree)*/
                                            {
                                              jjtree.closeNodeScope(jjtn000, true);
                                              jjtc000 = false;
                                            }
/*@egen*/  { jjtn000.token = token; jjtn000.token.image = "int[]"; }        |
    LOOKAHEAD(2) <INT>/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                            }
/*@egen*/      { jjtn000.token = token; }          |
    <VOID>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/          { jjtn000.token = token; }      |
    Identifier()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Statement()      : {}
{
    Block()         |
    If()            |
    While()         |
    Print()         |
    LOOKAHEAD(2) Assign()     |
    LOOKAHEAD(2) ArrayAssign()
}

void Block(): {/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Block */
  try {
/*@egen*/ <LBRACE> (Statement())* <RBRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }

void If(): {/*@bgen(jjtree) If */
  ASTIf jjtn000 = new ASTIf(JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) If */
  try {
/*@egen*/ <IF> <LPAREN> Exp() <RPAREN> Statement() (LOOKAHEAD(<ELSE>) <ELSE> Statement())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }

void While(): {/*@bgen(jjtree) While */
  ASTWhile jjtn000 = new ASTWhile(JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) While */
  try {
/*@egen*/ <WHILE> <LPAREN> Exp() <RPAREN> Statement()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }

void Print(): {/*@bgen(jjtree) Print */
  ASTPrint jjtn000 = new ASTPrint(JJTPRINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Print */
  try {
/*@egen*/ <PRINT> <LPAREN> Exp() <RPAREN> <SEMI>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }

void Assign(): {/*@bgen(jjtree) Assign */
  ASTAssign jjtn000 = new ASTAssign(JJTASSIGN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assign */
  try {
/*@egen*/ Identifier() <ASSIGN> Exp() <SEMI>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }

void ArrayAssign(): {/*@bgen(jjtree) ArrayAssign */
  ASTArrayAssign jjtn000 = new ASTArrayAssign(JJTARRAYASSIGN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArrayAssign */
  try {
/*@egen*/ Identifier() <LSQUARE> Exp() <RSQUARE> <ASSIGN> Exp() <SEMI>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }

void Exp()      : {}
{
    RelationalExp()
}

void RelationalExp()      : {}
{
    ArrayExp()/*@bgen(jjtree) #RelationalExp(> 1) */
               {
                 ASTRelationalExp jjtn001 = new ASTRelationalExp(JJTRELATIONALEXP);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
               }
               try {
/*@egen*/ (LOOKAHEAD(2) RelationalOperator() ArrayExp())*/*@bgen(jjtree)*/
               } catch (Throwable jjte001) {
                 if (jjtc001) {
                   jjtree.clearNodeScope(jjtn001);
                   jjtc001 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte001 instanceof RuntimeException) {
                   throw (RuntimeException)jjte001;
                 }
                 if (jjte001 instanceof ParseException) {
                   throw (ParseException)jjte001;
                 }
                 throw (Error)jjte001;
               } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                 }
               }
/*@egen*/                    
}

void ArrayExp()      : {}
{
    CallExp()/*@bgen(jjtree) #ArrayExp(> 1) */
              {
                ASTArrayExp jjtn001 = new ASTArrayExp(JJTARRAYEXP);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
              }
              try {
/*@egen*/ (LOOKAHEAD(2) <LSQUARE> CallExp() <RSQUARE>)*/*@bgen(jjtree)*/
              } catch (Throwable jjte001) {
                if (jjtc001) {
                  jjtree.clearNodeScope(jjtn001);
                  jjtc001 = false;
                } else {
                  jjtree.popNode();
                }
                if (jjte001 instanceof RuntimeException) {
                  throw (RuntimeException)jjte001;
                }
                if (jjte001 instanceof ParseException) {
                  throw (ParseException)jjte001;
                }
                throw (Error)jjte001;
              } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                }
              }
/*@egen*/                
}

void CallExp()      : {}
{
    Identifier()/*@bgen(jjtree) #CallExp(> 1) */
                 {
                   ASTCallExp jjtn001 = new ASTCallExp(JJTCALLEXP);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
                 }
                 try {
/*@egen*/ (<DOT> Identifier() <LPAREN> ExpList() <RPAREN>)+/*@bgen(jjtree)*/
                 } catch (Throwable jjte001) {
                   if (jjtc001) {
                     jjtree.clearNodeScope(jjtn001);
                     jjtc001 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte001 instanceof RuntimeException) {
                     throw (RuntimeException)jjte001;
                   }
                   if (jjte001 instanceof ParseException) {
                     throw (ParseException)jjte001;
                   }
                   throw (Error)jjte001;
                 } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                   }
                 }
/*@egen*/                  |
    AdditiveExp()/*@bgen(jjtree) #CallExp(> 1) */
                  {
                    ASTCallExp jjtn002 = new ASTCallExp(JJTCALLEXP);
                    boolean jjtc002 = true;
                    jjtree.openNodeScope(jjtn002);
                  }
                  try {
/*@egen*/ (<DOT> Identifier() <LPAREN> ExpList() <RPAREN>)*/*@bgen(jjtree)*/
                  } catch (Throwable jjte002) {
                    if (jjtc002) {
                      jjtree.clearNodeScope(jjtn002);
                      jjtc002 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte002 instanceof RuntimeException) {
                      throw (RuntimeException)jjte002;
                    }
                    if (jjte002 instanceof ParseException) {
                      throw (ParseException)jjte002;
                    }
                    throw (Error)jjte002;
                  } finally {
                    if (jjtc002) {
                      jjtree.closeNodeScope(jjtn002, jjtree.nodeArity() > 1);
                    }
                  }
/*@egen*/              
}

void AdditiveExp()      : {}
{
    MultiplicativeExp() (AdditiveOperator()/*@bgen(jjtree) #AdditiveExp( 2) */
                                            {
                                              ASTAdditiveExp jjtn001 = new ASTAdditiveExp(JJTADDITIVEEXP);
                                              boolean jjtc001 = true;
                                              jjtree.openNodeScope(jjtn001);
                                            }
                                            try {
/*@egen*/ MultiplicativeExp()/*@bgen(jjtree)*/
                                            } catch (Throwable jjte001) {
                                              if (jjtc001) {
                                                jjtree.clearNodeScope(jjtn001);
                                                jjtc001 = false;
                                              } else {
                                                jjtree.popNode();
                                              }
                                              if (jjte001 instanceof RuntimeException) {
                                                throw (RuntimeException)jjte001;
                                              }
                                              if (jjte001 instanceof ParseException) {
                                                throw (ParseException)jjte001;
                                              }
                                              throw (Error)jjte001;
                                            } finally {
                                              if (jjtc001) {
                                                jjtree.closeNodeScope(jjtn001,  2);
                                              }
                                            }
/*@egen*/                )*
}

void MultiplicativeExp()      : {}
{
    UnaryExp() (MultiplicativeOperator()/*@bgen(jjtree) #MultiplicativeExp( 2) */
                                         {
                                           ASTMultiplicativeExp jjtn001 = new ASTMultiplicativeExp(JJTMULTIPLICATIVEEXP);
                                           boolean jjtc001 = true;
                                           jjtree.openNodeScope(jjtn001);
                                         }
                                         try {
/*@egen*/ UnaryExp()/*@bgen(jjtree)*/
                                         } catch (Throwable jjte001) {
                                           if (jjtc001) {
                                             jjtree.clearNodeScope(jjtn001);
                                             jjtc001 = false;
                                           } else {
                                             jjtree.popNode();
                                           }
                                           if (jjte001 instanceof RuntimeException) {
                                             throw (RuntimeException)jjte001;
                                           }
                                           if (jjte001 instanceof ParseException) {
                                             throw (ParseException)jjte001;
                                           }
                                           throw (Error)jjte001;
                                         } finally {
                                           if (jjtc001) {
                                             jjtree.closeNodeScope(jjtn001,  2);
                                           }
                                         }
/*@egen*/                       )*
}

void UnaryExp()      : {}
{
    IntegerLiteral()        |
    BooleanLiteral()        |
    ThisLiteral()           |
    LOOKAHEAD(Identifier() <DOT>) LengthExp()             |
    Identifier()            |
    LOOKAHEAD(2) NewClassExp() |
    LOOKAHEAD(2) NewIntExp()   |
    NotExp()                |
    <LPAREN> Exp() <RPAREN>
}

void LengthExp(): {/*@bgen(jjtree) LengthExp */
  ASTLengthExp jjtn000 = new ASTLengthExp(JJTLENGTHEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LengthExp */
    try {
/*@egen*/
    Identifier() (<DOT> <LENGTH>)+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RelationalOperator(): {/*@bgen(jjtree) RelationalOperator */
  ASTRelationalOperator jjtn000 = new ASTRelationalOperator(JJTRELATIONALOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RelationalOperator */
  try {
/*@egen*/ (<LT> | <GT> | <AND>)/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ { jjtn000.token = token; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }

void AdditiveOperator(): {/*@bgen(jjtree) AdditiveOperator */
  ASTAdditiveOperator jjtn000 = new ASTAdditiveOperator(JJTADDITIVEOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AdditiveOperator */
    try {
/*@egen*/
    (<PLUS> | <MINUS>)/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { jjtn000.token = token; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MultiplicativeOperator(): {/*@bgen(jjtree) MultiplicativeOperator */
  ASTMultiplicativeOperator jjtn000 = new ASTMultiplicativeOperator(JJTMULTIPLICATIVEOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultiplicativeOperator */
    try {
/*@egen*/
    (<STAR> | <FSLASH>)/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ { jjtn000.token = token; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IntegerLiteral()      : {Token t;}
{/*@bgen(jjtree) IntegerConstNode */
    {
      ASTIntegerConstNode jjtn001 = new ASTIntegerConstNode(JJTINTEGERCONSTNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (
        t = <INTEGER_LITERAL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/
        { jjtn001.token = t; }
    )/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/                  
}

void BooleanLiteral()      : {}
{/*@bgen(jjtree) TrueNode */
    {
      ASTTrueNode jjtn001 = new ASTTrueNode(JJTTRUENODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    <TRUE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/                  |/*@bgen(jjtree) FalseNode */
    {
      ASTFalseNode jjtn002 = new ASTFalseNode(JJTFALSENODE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/
    <FALSE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/           
}

void ThisLiteral()      : {}
{/*@bgen(jjtree) ThisNode */
    {
      ASTThisNode jjtn001 = new ASTThisNode(JJTTHISNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    <THIS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/          
}

void NewIntExp()                 : {/*@bgen(jjtree) NewIntArrayNode */
  ASTNewIntArrayNode jjtn000 = new ASTNewIntArrayNode(JJTNEWINTARRAYNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NewIntArrayNode */
    try {
/*@egen*/
    <NEW> <INT> <LSQUARE> Exp() <RSQUARE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NewClassExp()              : {/*@bgen(jjtree) NewClassNode */
  ASTNewClassNode jjtn000 = new ASTNewClassNode(JJTNEWCLASSNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NewClassNode */
    try {
/*@egen*/
    <NEW> Identifier() <LPAREN> <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NotExp()         : {/*@bgen(jjtree) NotNode */
  ASTNotNode jjtn000 = new ASTNotNode(JJTNOTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NotNode */
    try {
/*@egen*/
    <EXCLAIM> Exp()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Identifier(): {/*@bgen(jjtree) Identifier */
                    ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/
    t = <IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { jjtn000.token = t; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExpList(): {/*@bgen(jjtree) ExpList */
  ASTExpList jjtn000 = new ASTExpList(JJTEXPLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExpList */
    try {
/*@egen*/
    (Exp() (ExpRest())*)?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExpRest(): {/*@bgen(jjtree) ExpRest */
  ASTExpRest jjtn000 = new ASTExpRest(JJTEXPREST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExpRest */
    try {
/*@egen*/
    <COMMA> Exp()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}